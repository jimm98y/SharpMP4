{
  "name": "Descriptors",
  "description": "Descriptors",
  "entries": [
    {
      "type": "Descriptor",
      "containers": [ "*" ],
      "syntax": "class AudioSpecificConfig() {\r\n  GetAudioObjectType() audioObjectType;\r\n  bslbf(4) samplingFrequencyIndex;\r\n  if(samplingFrequencyIndex == 0xf ) {\r\n    uimsbf(24) samplingFrequency;\r\n  }\r\n  bslbf(4) channelConfiguration;\r\n  sbrPresentFlag = -1;\r\n  psPresentFlag = -1;\r\n\r\n  if (audioObjectType == 5 || audioObjectType == 29) {\r\n    extensionAudioObjectType = 5;\r\n    sbrPresentFlag = 1;\r\n    if (audioObjectType == 29) {\r\n      psPresentFlag = 1;\r\n    }\r\n    uimsbf(4) extensionSamplingFrequencyIndex;\r\n    if (extensionSamplingFrequencyIndex == 0xf)\r\n      uimsbf(24) extensionSamplingFrequency;\r\n    GetAudioObjectType() audioObjectType;\r\n    if (audioObjectType == 22)\r\n      uimsbf(4) extensionChannelConfiguration;\r\n  }\r\n  else {\r\n    extensionAudioObjectType = 0;\r\n  }\r\n  switch (audioObjectType) {\r\n    case 1:\r\n    case 2:\r\n    case 3:\r\n    case 4:\r\n    case 6:\r\n    case 7:\r\n    case 17:\r\n    case 19:\r\n    case 20:\r\n    case 21:\r\n    case 22:\r\n    case 23:\r\n      GASpecificConfig();\r\n      break;\r\n    case 8:\r\n      CelpSpecificConfig();\r\n      break;\r\n    case 9:\r\n      HvxcSpecificConfig();\r\n      break;\r\n    case 12:\r\n      TTSSpecificConfig();\r\n      break;\r\n    case 13:\r\n    case 14:\r\n    case 15:\r\n    case 16:\r\n      StructuredAudioSpecificConfig();\r\n      break;\r\n    case 24:\r\n      ErrorResilientCelpSpecificConfig();\r\n      break;\r\n    case 25:\r\n      ErrorResilientHvxcSpecificConfig();\r\n      break;\r\n    case 26:\r\n    case 27:\r\n      ParametricSpecificConfig();\r\n      break;\r\n    case 28:\r\n      SSCSpecificConfig();\r\n      break;\r\n    case 30:\r\n      uimsbf(1) sacPayloadEmbedding;\r\n      SpatialSpecificConfig();\r\n      break;\r\n    case 32:\r\n    case 33:\r\n    case 34:\r\n      MPEG_1_2_SpecificConfig();\r\n      break;\r\n    case 35:\r\n      DSTSpecificConfig();\r\n      break;\r\n    case 36:\r\n      bslbf(5) fillBits;\r\n      ALSSpecificConfig();\r\n      break;\r\n    case 37:\r\n    case 38:\r\n      SLSSpecificConfig();\r\n      break;\r\n    case 39:\r\n      ELDSpecificConfig(channelConfiguration);\r\n      break;\r\n    case 40:\r\n    case 41:\r\n      SymbolicMusicSpecificConfig();\r\n      break;\r\n    default:\r\n      /* reserved */\r\n      break;\r\n  }\r\n  switch (audioObjectType) {\r\n    case 17:\r\n    case 19:\r\n    case 20:\r\n    case 21:\r\n    case 22:\r\n    case 23:\r\n    case 24:\r\n    case 25:\r\n    case 26:\r\n    case 27:\r\n    case 39:\r\n      bslbf(2) epConfig;\r\n      if (epConfig == 2 || epConfig == 3) {\r\n        ErrorProtectionSpecificConfig();\r\n      }\r\n      if (epConfig == 3) {\r\n        bslbf(1) directMapping;\r\n        if (!directMapping) {\r\n          /* tbd */\r\n        }\r\n      }\r\n      break;\r\n  }\r\n  if (extensionAudioObjectType != 5 && bits_to_decode() >= 16) {\r\n    bslbf(11) syncExtensionType;\r\n    if (syncExtensionType == 0x2b7) {\r\n      GetAudioObjectType() extensionAudioObjectType;\r\n      if (extensionAudioObjectType == 5) {\r\n        uimsbf(1) sbrPresentFlag;\r\n        if (sbrPresentFlag == 1) {\r\n          uimsbf(4) extensionSamplingFrequencyIndex;\r\n          if (extensionSamplingFrequencyIndex == 0xf) {\r\n            uimsbf(24) extensionSamplingFrequency;\r\n          }\r\n          if (bits_to_decode() >= 12) {\r\n            bslbf(11) syncExtensionType;\r\n            if (syncExtensionType == 0x548) {\r\n              uimsbf(1) psPresentFlag;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      if (extensionAudioObjectType == 22) {\r\n        uimsbf(1) sbrPresentFlag;\r\n        if (sbrPresentFlag == 1) {\r\n          uimsbf(4) extensionSamplingFrequencyIndex;\r\n          if (extensionSamplingFrequencyIndex == 0xf) {\r\n            uimsbf(24) extensionSamplingFrequency;\r\n          }\r\n        }\r\n        uimsbf(4) extensionChannelConfiguration;\r\n      }\r\n    }\r\n  }   \r\n}\r\n\r\nclass GetAudioObjectType()\r\n{\r\n  uimsbf(5) audioObjectType;\r\n  if (audioObjectType == 31) {\r\n    uimsbf(6) audioObjectTypeExt;\r\n    audioObjectType = 32 + audioObjectTypeExt;\r\n  }\r\n  return audioObjectType;\r\n}\r\n\r\nclass GASpecificConfig(samplingFrequencyIndex, channelConfiguration, audioObjectType)\r\n{\r\n  bslbf(1) frameLengthFlag;\r\n  bslbf(1) dependsOnCoreCoder;\r\n  if (dependsOnCoreCoder) {\r\n    uimsbf(14) coreCoderDelay;\r\n  }\r\n  bslbf(1) extensionFlag;\r\n  if (!channelConfiguration) {\r\n    program_config_element();\r\n  }\r\n  if ((audioObjectType == 6) || (audioObjectType == 20)) {\r\n    uimsbf(3) layerNr;\r\n  }\r\n  if (extensionFlag) {\r\n    if (audioObjectType == 22) {\r\n      bslbf(5) numOfSubFrame;\r\n      bslbf(11) layer_length;\r\n    }\r\n    if (audioObjectType == 17 || audioObjectType == 19 ||\r\n      audioObjectType == 20 || audioObjectType == 23) {\r\n\r\n      bslbf(1) aacSectionDataResilienceFlag;\r\n      bslbf(1) aacScalefactorDataResilienceFlag;\r\n      bslbf(1) aacSpectralDataResilienceFlag;\r\n    }\r\n    bslbf(1) extensionFlag3;\r\n    if (extensionFlag3) {\r\n      /* tbd in version 3 */\r\n    }\r\n  }\r\n}\r\n\r\nclass program_config_element()\r\n{\r\n  uimsbf(4) element_instance_tag;\r\n  uimsbf(2) object_type;\r\n  uimsbf(4) sampling_frequency_index;\r\n  uimsbf(4) num_front_channel_elements;\r\n  uimsbf(4) num_side_channel_elements;\r\n  uimsbf(4) num_back_channel_elements;\r\n  uimsbf(2) num_lfe_channel_elements;\r\n  uimsbf(3) num_assoc_data_elements;\r\n  uimsbf(4) num_valid_cc_elements;\r\n  uimsbf(1) mono_mixdown_present;\r\n  if (mono_mixdown_present == 1)\r\n    uimsbf(4) mono_mixdown_element_number;\r\n  uimsbf(1) stereo_mixdown_present;\r\n  if (stereo_mixdown_present == 1)\r\n    uimsbf(4) stereo_mixdown_element_number;\r\n  uimsbf(1) matrix_mixdown_idx_present;\r\n  if (matrix_mixdown_idx_present == 1) {\r\n    uimsbf(2) matrix_mixdown_idx;\r\n    uimsbf(1) pseudo_surround_enable;\r\n  }\r\n  for (i = 0; i < num_front_channel_elements; i++) {\r\n    bslbf(1) front_element_is_cpe[i];\r\n    uimsbf(4) front_element_tag_select[i];\r\n  }\r\n  for (i = 0; i < num_side_channel_elements; i++) {\r\n    bslbf(1) side_element_is_cpe[i];\r\n    uimsbf(4) side_element_tag_select[i];\r\n  }\r\n  for (i = 0; i < num_back_channel_elements; i++) {\r\n    bslbf(1) back_element_is_cpe[i];\r\n    uimsbf(4) back_element_tag_select[i];\r\n  }\r\n  for (i = 0; i < num_lfe_channel_elements; i++)\r\n    uimsbf(4) lfe_element_tag_select[i];\r\n  for (i = 0; i < num_assoc_data_elements; i++)\r\n    uimsbf(4) assoc_data_element_tag_select[i];\r\n  for (i = 0; i < num_valid_cc_elements; i++) {\r\n    uimsbf(1) cc_element_is_ind_sw[i];\r\n    uimsbf(4) valid_cc_element_tag_select[i];\r\n  }\r\n  byte_alignment();  // Note 1 \r\n  uimsbf(8) comment_field_bytes;\r\n  for (i = 0; i < comment_field_bytes; i++)\r\n    uimsbf(8) comment_field_data[i];\r\n}\r\n\r\nclass CelpSpecificConfig(samplingFrequencyIndex)\r\n{\r\n  uimsbf(1) isBaseLayer;\r\n  if (isBaseLayer) {\r\n    CelpHeader(samplingFrequencyIndex);\r\n  }\r\n  else {\r\n    uimsbf(1) isBWSLayer;\r\n    if (isBWSLayer) {\r\n      CelpBWSenhHeader();\r\n    }\r\n    else {\r\n      uimsbf(2) CELPBRSid;\r\n    }\r\n  }\r\n}\r\n\r\nclass CelpHeader(samplingFrequencyIndex)\r\n{\r\n  uimsbf(1) ExcitationMode;\r\n  uimsbf(1) SampleRateMode;\r\n  uimsbf(1) FineRateControl;\r\n  if (ExcitationMode == RPE) {\r\n    uimsbf(3) RPE_Configuration;\r\n  }\r\n  if (ExcitationMode == MPE) {\r\n    uimsbf(5) MPE_Configuration;\r\n    uimsbf(2) NumEnhLayers;\r\n    uimsbf(1) BandwidthScalabilityMode;\r\n  }\r\n}\r\n\r\nclass CelpBWSenhHeader()\r\n{\r\n  uimsbf(2) BWS_configuration;\r\n}\r\n\r\nclass HvxcSpecificConfig() {\r\n  uimsbf(1) isBaseLayer;\r\n  if (isBaseLayer) {\r\n    HVXCconfig();\r\n  }\r\n}\r\n\r\nclass HVXCconfig()\r\n{\r\n  uimsbf(1) HVXCvarMode;\r\n  uimsbf(2) HVXCrateMode;\r\n  uimsbf(1) extensionFlag;\r\n  if (extensionFlag) {\r\n    // to be defined in MPEG-4 Version 2\r\n  }\r\n}\r\n\r\nclass TTSSpecificConfig() {\r\n    TTS_Sequence();\r\n}\r\n\r\nclass TTS_Sequence()\r\n{\r\n  uimsbf(5) TTS_Sequence_ID;\r\n  uimsbf(18) Language_Code;\r\n  bslbf(1) Gender_Enable;\r\n  bslbf(1) Age_Enable;\r\n  bslbf(1) Speech_Rate_Enable;\r\n  bslbf(1) Prosody_Enable;\r\n  bslbf(1) Video_Enable;\r\n  bslbf(1) Lip_Shape_Enable;\r\n  bslbf(1) Trick_Mode_Enable;\r\n}\r\n\r\nclass ErrorResilientCelpSpecificConfig(samplingFrequencyIndex)\r\n{\r\n  uimsbf(1) isBaseLayer;\r\n  if (isBaseLayer) {\r\n    ER_SC_CelpHeader(samplingFrequencyIndex);\r\n  }\r\n  else {\r\n    uimsbf(1) isBWSLayer;\r\n    if (isBWSLayer) {\r\n      CelpBWSenhHeader();\r\n    }\r\n    else {\r\n      uimsbf(2) CELPBRSid;\r\n    }\r\n  }\r\n}\r\n\r\nclass ER_SC_CelpHeader(samplingFrequencyIndex)\r\n{\r\n  uimsbf(1) ExcitationMode;\r\n  uimsbf(1) SampleRateMode;\r\n  uimsbf(1) FineRateControl;\r\n  uimsbf(1) SilenceCompression;\r\n  if (ExcitationMode == RPE) {\r\n    uimsbf(3) RPE_Configuration;\r\n  }\r\n  if (ExcitationMode == MPE) {\r\n    uimsbf(5) MPE_Configuration;\r\n    uimsbf(2) NumEnhLayers;\r\n    uimsbf(1) BandwidthScalabilityMode;\r\n  }\r\n}\r\n\r\nclass ErrorResilientHvxcSpecificConfig() {\r\n  uimsbf(1) isBaseLayer;\r\n  if (isBaseLayer) {\r\n    ErHVXCconfig();\r\n  }\r\n}\r\n\r\nclass ErHVXCconfig()\r\n{\r\n  uimsbf(1) HVXCvarMode;\r\n  uimsbf(2) HVXCrateMode;\r\n  uimsbf(1) extensionFlag;\r\n  if (extensionFlag) {\r\n    uimsbf(1) var_ScalableFlag;\r\n  }\r\n}\r\n\r\nclass ParametricSpecificConfig()\r\n{\r\n  uimsbf(1) isBaseLayer;\r\n  if (isBaseLayer) {\r\n    PARAconfig();\r\n  }\r\n  else {\r\n    HILNenexConfig();\r\n  }\r\n}\r\n\r\nclass PARAconfig()\r\n{\r\n  uimsbf(2) PARAmode;\r\n  if (PARAmode != 1) {\r\n    ErHVXCconfig();\r\n  }\r\n  if (PARAmode != 0) {\r\n    HILNconfig();\r\n  }\r\n  uimsbf(1) PARAextensionFlag;\r\n  if (PARAextensionFlag) {\r\n    /* to be defined in MPEG-4 Phase 3 */\r\n  }\r\n}\r\n\r\nclass HILNconfig()\r\n{\r\n  uimsbf(1) HILNquantMode;\r\n  uimsbf(8) HILNmaxNumLine;\r\n  uimsbf(4) HILNsampleRateCode;\r\n  uimsbf(12) HILNframeLength;\r\n  uimsbf(2) HILNcontMode;\r\n}\r\n\r\nclass HILNenexConfig()\r\n{\r\n  uimsbf(1) HILNenhaLayer;\r\n  if (HILNenhaLayer) {\r\n    uimsbf(2) HILNenhaQuantMode;\r\n  }\r\n}\r\n\r\nclass SSCSpecificConfig(channelConfiguration)\r\n{\r\n  uimsbf(2) decoder_level;\r\n  uimsbf(4) update_rate;\r\n  uimsbf(2) synthesis_method;\r\n  if (channelConfiguration != 1) {\r\n    uimsbf(2) mode_ext;\r\n    if ((channelConfiguration == 2) && (mode_ext == 1)) {\r\n      uimsbf(2) reserved;\r\n    }\r\n  }\r\n}\r\n\r\nclass MPEG_1_2_SpecificConfig()\r\n{\r\n  bslbf(1) extension;\r\n}\r\n\r\nclass DSTSpecificConfig(channelConfiguration) {\r\n  uimsbf(1) DSDDST_Coded;\r\n  uimsbf(14) N_Channels;\r\n  uimsbf(1) reserved;\r\n}\r\n\r\nclass ALSSpecificConfig()\r\n{\r\n  uimsbf(32) als_id;\r\n  uimsbf(32) samp_freq;\r\n  uimsbf(32) samples;\r\n  uimsbf(16) channels;\r\n  uimsbf(3) file_type;\r\n  uimsbf(3) resolution;\r\n  uimsbf(1) floating;\r\n  uimsbf(1) msb_first;\r\n  uimsbf(16) frame_length;\r\n  uimsbf(8) random_access;\r\n  uimsbf(2) ra_flag;\r\n  uimsbf(1) adapt_order;\r\n  uimsbf(2) coef_table;\r\n  uimsbf(1) long_term_prediction;\r\n  uimsbf(10) max_order;\r\n  uimsbf(2) block_switching;\r\n  uimsbf(1) bgmc_mode;\r\n  uimsbf(1) sb_part;\r\n  uimsbf(1) joint_stereo;\r\n  uimsbf(1) mc_coding;\r\n  uimsbf(1) chan_config;\r\n  uimsbf(1) chan_sort;\r\n  uimsbf(1) crc_enabled;\r\n  uimsbf(1) RLSLMS;\r\n  uimsbf(5) reserved;\r\n  uimsbf(1) aux_data_enabled;\r\n  if (chan_config) {\r\n    uimsbf(16) chan_config_info;\r\n  }\r\n  if (chan_sort) {\r\n    for (c = 0; c <= channels; c++)\r\n      uimsbf(1) chan_pos[c]; // 1..16 uimsbf \r\n  }\r\n  bslbf(1) byte_align; // TODO: 0..7 bslbf \r\n  uimsbf(32) header_size;\r\n  uimsbf(32) trailer_size;\r\n  bslbf(header_size * 8) orig_header[];\r\n  bslbf(trailer_size * 8) orig_trailer[];\r\n  if (crc_enabled) {\r\n    uimsbf(32) crc;\r\n  }\r\n  if ((ra_flag == 2) && (random_access > 0)) {\r\n    for (f = 0; f < ((samples - 1) / (frame_length + 1)) + 1; f++) {\r\n      uimsbf(32) ra_unit_size[f];\r\n    }\r\n  }\r\n  if (aux_data_enabled) {\r\n    uimsbf(32) aux_size;\r\n    bslbf(aux_size * 8) aux_data[];\r\n  }\r\n}\r\n\r\nclass SLSSpecificConfig(samplingFrequencyIndex,\r\n  channelConfiguration,\r\n  audioObjectType)\r\n{\r\n  uimsbf(3) pcmWordLength;\r\n  uimsbf(1) aac_core_present;\r\n  uimsbf(1) lle_main_stream;\r\n  uimsbf(1) reserved_bit;\r\n  uimsbf(3) frameLength;\r\n  if (!channelConfiguration) {\r\n    program_config_element();\r\n  }\r\n}\r\n\r\nclass ELDSpecificConfig(channelConfiguration)\r\n{\r\n  bslbf(1) frameLengthFlag;\r\n  bslbf(1) aacSectionDataResilienceFlag;\r\n  bslbf(1) aacScalefactorDataResilienceFlag;\r\n  bslbf(1) aacSpectralDataResilienceFlag;\r\n\r\n  bslbf(1) ldSbrPresentFlag;\r\n  if (ldSbrPresentFlag) {\r\n    bslbf(1) ldSbrSamplingRate;\r\n    bslbf(1) ldSbrCrcFlag;\r\n    ld_sbr_header(channelConfiguration);\r\n  }\r\n\r\n  bslbf(4) eldExtType;\r\nwhile (eldExtType != ELDEXT_TERM) {\r\n    uimsbf(4) eldExtLen;\r\n    len = eldExtLen;\r\n    if (eldExtLen == 15) {\r\n      uimsbf(8) eldExtLenAdd;\r\n      len += eldExtLenAdd;\r\n    }\r\n    if (eldExtLenAdd == 255) {\r\n      uimsbf(16) eldExtLenAddAdd;\r\n      len += eldExtLenAddAdd;\r\n    }\r\n    switch (eldExtType) {\r\n      /* add future eld extension configs here */\r\n      default:\r\n        int cntt;\r\n        for (cnt = 0; cnt < len; cnt++) {\r\n           uimsbf(8) other_byte;\r\n        }\r\n        break;\r\n    }\r\nbslbf(4) eldExtType;\r\n  }\r\n}\r\n\r\nclass ld_sbr_header(channelConfiguration)\r\n{\r\n  switch (channelConfiguration) {\r\n    case 1:\r\n    case 2:\r\n      numSbrHeader = 1;\r\n      break;\r\n    case 3:\r\n      numSbrHeader = 2;\r\n      break;\r\n    case 4:\r\n    case 5:\r\n    case 6:\r\n      numSbrHeader = 3;\r\n      break;\r\n    case 7:\r\n      numSbrHeader = 4;\r\n      break;\r\n    default:\r\n      numSbrHeader = 0;\r\n      break;\r\n  }\r\n  for (el = 0; el < numSbrHeader; el++) {\r\n    sbr_header();\r\n  }\r\n}\r\n\r\nclass sbr_header()\r\n{\r\n  uimsbf(1) bs_amp_res;\r\n  uimsbf(4) bs_start_freq;\r\n  uimsbf(4) bs_stop_freq;\r\n  uimsbf(3) bs_xover_band;\r\n  uimsbf(2) bs_reserved;\r\n  uimsbf(1) bs_header_extra_1;\r\n  uimsbf(1) bs_header_extra_2;\r\n\r\n  if (bs_header_extra_1) {\r\n    uimsbf(2) bs_freq_scale;\r\n    uimsbf(1) bs_alter_scale;\r\n    uimsbf(2) bs_noise_bands;\r\n  }\r\n\r\n  if (bs_header_extra_2) {\r\n    uimsbf(2) bs_limiter_bands;\r\n    uimsbf(2) bs_limiter_gains;\r\n    uimsbf(1) bs_interpol_freq;\r\n    uimsbf(1) bs_smoothing_mode;\r\n  }\r\n}\r\n\r\nclass ErrorProtectionSpecificConfig()\r\n{\r\n  uimsbf(8) number_of_predefined_set;\r\n  uimsbf(2) interleave_type;\r\n  uimsbf(3) bit_stuffing;\r\n  uimsbf(3) number_of_concatenated_frame;\r\n  for (i = 0; i < number_of_predefined_set; i++) {\r\n    uimsbf(6) number_of_class[i];\r\n    for (j = 0; j < number_of_class[i]; j++) {\r\n      uimsbf(1) length_escape[i][j];\r\n      uimsbf(1) rate_escape[i][j];\r\n      uimsbf(1) crclen_escape[i][j];\r\n      if (number_of_concatenated_frame != 1) {\r\n        uimsbf(1) concatenate_flag[i][j];\r\n      }\r\n      uimsbf(2) fec_type[i][j];\r\n      if (fec_type[i][j] == 0) {\r\n        uimsbf(1) termination_switch[i][j];\r\n      }\r\n      if (interleave_type == 2) {\r\n        uimsbf(2) interleave_switch[i][j];\r\n      }\r\n      uimsbf(1) class_optional;\r\n      if (length_escape[i][j] == 1) { /* ESC */\r\n        uimsbf(4) number_of_bits_for_length[i][j];\r\n      }\r\n      else {\r\n        uimsbf(16) class_length[i][j];\r\n      }\r\n      if (rate_escape[i][j] != 1) { /* not ESC */\r\n        if (fec_type[i][j]) {\r\n          uimsbf(7) class_rate[i][j];\r\n        } else {\r\n          uimsbf(5) class_rate[i][j];\r\n        }\r\n      }\r\n      if (crclen_escape[i][j] != 1) {  /* not ESC */\r\n        uimsbf(5) class_crclen[i][j];\r\n      }\r\n    }\r\n    uimsbf(1) class_reordered_output;\r\n    if (class_reordered_output == 1) {\r\n      for (j = 0; j < number_of_class[i]; j++) {\r\n        uimsbf(6) class_output_order[i][j];\r\n      }\r\n    }\r\n  }\r\n  uimsbf(1) header_protection;\r\n  if (header_protection == 1) {\r\n    uimsbf(5) header_rate;\r\n    uimsbf(5) header_crclen;\r\n  }\r\n}\r\n"
    }
  ]
}